import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import validatorService from "./validatorService";
import { SOMETHING_WRONG } from "../multisig/multisigSlice";
import cloneDeep from "lodash/cloneDeep";

const initialState = {
  chains: {},
  defaultState: {
    delegations: {
      status: "",
      records: {},
      errMsg: "",
      pagination: {},
    },
    tx: {
      status: "idle",
      type: "",
    },
  },
};

export const getAllDelegators = createAsyncThunk(
  "validator/all-delegators",
  async (data, { rejectWithValue }) => {
    try {
      const delegators = [];
      let nextKey = null;
      const limit = 100;
      while (true) {
        const response = await validatorService.delegations(
          data.baseURL,
          data?.validator,
          nextKey
            ? {
                key: nextKey,
                limit: limit,
              }
            : {}
        );
        delegators.push(...response.data.delegation_responses);
        if (!response.data.pagination?.next_key) {
          break;
        }
        nextKey = response.data.pagination.next_key;
      }
      return {
        delegators: delegators,
        chainID: data.chainID,
      };
    } catch (error) {
      return rejectWithValue(error?.message || SOMETHING_WRONG);
    }
  }
);

export const validatorSlice = createSlice({
  name: "validator",
  initialState,
  reducers: {
    resetDelegators: (state, action) => {
        const chainID = action.payload.chainID;
        state.chains[chainID] = state.defaultState;
      },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getAllDelegators.pending, (state, action) => {
        const chainID = action.meta?.arg?.chainID;
        if (!state.chains[chainID]) {
          state.chains[chainID] = state.defaultState;
        }
        state.chains[chainID].delegations.status = "pending";
        state.chains[chainID].delegations.errMsg = "";
      })
      .addCase(getAllDelegators.fulfilled, (state, action) => {
        let chainID = action.meta?.arg?.chainID;
        state.chains[chainID].delegations.status = "idle";
        for (let i = 0; i < action.payload.delegators.length; i++) {
          state.chains[chainID].delegations.records[
            action.payload.delegators[i].delegation.delegator_address
          ] = action.payload.delegators[i].balance;
        }
      })
      .addCase(getAllDelegators.rejected, (state, action) => {
        let chainID = action.meta?.arg?.chainID;
        let result = cloneDeep(initialState.defaultState.delegations);
        result.errMsg = action.error.message;
        result.status = "rejected";
        if (state.chains[chainID]) {
          state.chains[chainID].delegations = result;
        }
      });
  },
});

export const {
    resetDelegators
  } = validatorSlice.actions;

export default validatorSlice.reducer;
